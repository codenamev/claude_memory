# frozen_string_literal: true

require "digest"
require "fileutils"

module ClaudeMemory
  class Publish
    RULES_DIR = ".claude/rules"
    GENERATED_FILE = "claude_memory.generated.md"

    def initialize(store)
      @store = store
    end

    def generate_snapshot(since: nil)
      facts = fetch_active_facts
      conflicts = @store.open_conflicts
      recent_supersessions = fetch_recent_supersessions(since)

      sections = []
      sections << generate_decisions_section(facts)
      sections << generate_conventions_section(facts)
      sections << generate_constraints_section(facts)
      sections << generate_conflicts_section(conflicts) if conflicts.any?
      sections << generate_supersessions_section(recent_supersessions) if recent_supersessions.any?

      header = <<~HEADER
        <!-- 
          This file is auto-generated by claude-memory.
          Do not edit manually - changes will be overwritten.
          Generated: #{Time.now.utc.iso8601}
        -->

        # Project Memory

      HEADER

      header + sections.compact.reject(&:empty?).join("\n")
    end

    def publish!(mode: :shared, granularity: :repo, since: nil)
      content = generate_snapshot(since: since)
      path = case mode
      when :shared
        File.join(RULES_DIR, GENERATED_FILE)
      when :local
        ".claude_memory.local.md"
      end

      FileUtils.mkdir_p(File.dirname(path))

      if should_write?(path, content)
        File.write(path, content)
        ensure_import_exists if mode == :shared
        {status: :updated, path: path}
      else
        {status: :unchanged, path: path}
      end
    end

    private

    def fetch_active_facts
      rows = @store.execute(<<~SQL)
        SELECT f.id, f.predicate, f.object_literal, f.status, f.confidence, f.created_at,
               e.canonical_name as subject_name
        FROM facts f
        LEFT JOIN entities e ON f.subject_entity_id = e.id
        WHERE f.status = 'active'
        ORDER BY f.created_at DESC
        LIMIT 100
      SQL

      rows.map do |r|
        {id: r[0], predicate: r[1], object_literal: r[2], status: r[3], confidence: r[4], created_at: r[5], subject_name: r[6]}
      end
    end

    def fetch_recent_supersessions(since)
      return [] unless since

      rows = @store.execute(<<~SQL, [since])
        SELECT f.id, f.predicate, f.object_literal, f.valid_to,
               e.canonical_name as subject_name
        FROM facts f
        LEFT JOIN entities e ON f.subject_entity_id = e.id
        WHERE f.status = 'superseded' AND f.valid_to >= ?
        ORDER BY f.valid_to DESC
        LIMIT 20
      SQL

      rows.map do |r|
        {id: r[0], predicate: r[1], object_literal: r[2], valid_to: r[3], subject_name: r[4]}
      end
    end

    def generate_decisions_section(facts)
      decisions = facts.select { |f| f[:predicate] == "decision" || f[:predicate]&.start_with?("decided_") }
      return "" if decisions.empty?

      lines = ["## Current Decisions\n"]
      decisions.each do |d|
        lines << "- #{d[:object_literal]}"
      end
      lines.join("\n") + "\n"
    end

    def generate_conventions_section(facts)
      conventions = facts.select { |f| f[:predicate] == "convention" || f[:predicate]&.include?("_convention") }
      return "" if conventions.empty?

      lines = ["## Conventions\n"]
      conventions.each do |c|
        lines << "- #{c[:object_literal]}"
      end
      lines.join("\n") + "\n"
    end

    def generate_constraints_section(facts)
      constraints = facts.select do |f|
        %w[uses_database uses_framework deployment_platform auth_method].include?(f[:predicate])
      end
      return "" if constraints.empty?

      lines = ["## Technical Constraints\n"]
      constraints.each do |c|
        lines << "- **#{humanize(c[:predicate])}**: #{c[:object_literal]}"
      end
      lines.join("\n") + "\n"
    end

    def generate_conflicts_section(conflicts)
      return "" if conflicts.empty?

      lines = ["## Open Conflicts\n"]
      lines << "The following facts are in conflict and need resolution:\n"
      conflicts.each do |c|
        lines << "- Conflict ##{c[:id]}: Fact #{c[:fact_a_id]} vs Fact #{c[:fact_b_id]}"
      end
      lines.join("\n") + "\n"
    end

    def generate_supersessions_section(supersessions)
      return "" if supersessions.empty?

      lines = ["## Recent Changes\n"]
      supersessions.each do |s|
        lines << "- [Superseded] #{s[:subject_name]}.#{s[:predicate]}: #{s[:object_literal]} (until #{s[:valid_to]})"
      end
      lines.join("\n") + "\n"
    end

    def should_write?(path, content)
      return true unless File.exist?(path)

      existing_hash = Digest::SHA256.file(path).hexdigest
      new_hash = Digest::SHA256.hexdigest(content)
      existing_hash != new_hash
    end

    def ensure_import_exists
      claude_md = ".claude/CLAUDE.md"
      import_line = "@#{RULES_DIR}/#{GENERATED_FILE}"

      if File.exist?(claude_md)
        content = File.read(claude_md)
        return if content.include?(import_line)

        File.write(claude_md, content + "\n#{import_line}\n")
      else
        FileUtils.mkdir_p(".claude")
        File.write(claude_md, "# Project Memory\n\n#{import_line}\n")
      end
    end

    def humanize(predicate)
      predicate.tr("_", " ").capitalize
    end
  end
end
