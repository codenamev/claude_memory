# frozen_string_literal: true

require "digest"
require "fileutils"

module ClaudeMemory
  class Publish
    RULES_DIR = ".claude/rules"
    GENERATED_FILE = "claude_memory.generated.md"

    def initialize(store)
      @store = store
    end

    def generate_snapshot(since: nil)
      facts = fetch_active_facts
      conflicts = @store.open_conflicts
      recent_supersessions = fetch_recent_supersessions(since)

      sections = []
      sections << generate_decisions_section(facts)
      sections << generate_conventions_section(facts)
      sections << generate_constraints_section(facts)
      sections << generate_conflicts_section(conflicts) if conflicts.any?
      sections << generate_supersessions_section(recent_supersessions) if recent_supersessions.any?

      header = <<~HEADER
        <!-- 
          This file is auto-generated by claude-memory.
          Do not edit manually - changes will be overwritten.
          Generated: #{Time.now.utc.iso8601}
        -->

        # Project Memory

      HEADER

      header + sections.compact.reject(&:empty?).join("\n")
    end

    def publish!(mode: :shared, granularity: :repo, since: nil)
      content = generate_snapshot(since: since)
      path = output_path(mode)

      FileUtils.mkdir_p(File.dirname(path))

      if should_write?(path, content)
        File.write(path, content)
        ensure_import_exists(mode, path)
        {status: :updated, path: path}
      else
        {status: :unchanged, path: path}
      end
    end

    private

    def output_path(mode)
      case mode
      when :shared
        File.join(RULES_DIR, GENERATED_FILE)
      when :local
        ".claude_memory.local.md"
      when :home
        project_name = File.basename(Dir.pwd)
        File.join(Dir.home, ".claude", "claude_memory", "#{project_name}.md")
      else
        File.join(RULES_DIR, GENERATED_FILE)
      end
    end

    def fetch_active_facts
      @store.facts
        .left_join(:entities, id: :subject_entity_id)
        .select(
          Sequel[:facts][:id],
          Sequel[:facts][:predicate],
          Sequel[:facts][:object_literal],
          Sequel[:facts][:status],
          Sequel[:facts][:confidence],
          Sequel[:facts][:created_at],
          Sequel[:entities][:canonical_name].as(:subject_name)
        )
        .where(Sequel[:facts][:status] => "active")
        .order(Sequel.desc(Sequel[:facts][:created_at]))
        .limit(100)
        .all
    end

    def fetch_recent_supersessions(since)
      return [] unless since

      @store.facts
        .left_join(:entities, id: :subject_entity_id)
        .select(
          Sequel[:facts][:id],
          Sequel[:facts][:predicate],
          Sequel[:facts][:object_literal],
          Sequel[:facts][:valid_to],
          Sequel[:entities][:canonical_name].as(:subject_name)
        )
        .where(Sequel[:facts][:status] => "superseded")
        .where { Sequel[:facts][:valid_to] >= since }
        .order(Sequel.desc(Sequel[:facts][:valid_to]))
        .limit(20)
        .all
    end

    def generate_decisions_section(facts)
      decisions = facts.select { |f| f[:predicate] == "decision" || f[:predicate]&.start_with?("decided_") }
      return "" if decisions.empty?

      lines = ["## Current Decisions\n"]
      decisions.each do |d|
        lines << "- #{d[:object_literal]}"
      end
      lines.join("\n") + "\n"
    end

    def generate_conventions_section(facts)
      conventions = facts.select { |f| f[:predicate] == "convention" || f[:predicate]&.include?("_convention") }
      return "" if conventions.empty?

      lines = ["## Conventions\n"]
      conventions.each do |c|
        lines << "- #{c[:object_literal]}"
      end
      lines.join("\n") + "\n"
    end

    def generate_constraints_section(facts)
      constraints = facts.select do |f|
        %w[uses_database uses_framework deployment_platform auth_method].include?(f[:predicate])
      end
      return "" if constraints.empty?

      lines = ["## Technical Constraints\n"]
      constraints.each do |c|
        lines << "- **#{humanize(c[:predicate])}**: #{c[:object_literal]}"
      end
      lines.join("\n") + "\n"
    end

    def generate_conflicts_section(conflicts)
      return "" if conflicts.empty?

      lines = ["## Open Conflicts\n"]
      lines << "The following facts are in conflict and need resolution:\n"
      conflicts.each do |c|
        lines << "- Conflict ##{c[:id]}: Fact #{c[:fact_a_id]} vs Fact #{c[:fact_b_id]}"
      end
      lines.join("\n") + "\n"
    end

    def generate_supersessions_section(supersessions)
      return "" if supersessions.empty?

      lines = ["## Recent Changes\n"]
      supersessions.each do |s|
        lines << "- [Superseded] #{s[:subject_name]}.#{s[:predicate]}: #{s[:object_literal]} (until #{s[:valid_to]})"
      end
      lines.join("\n") + "\n"
    end

    def should_write?(path, content)
      return true unless File.exist?(path)

      existing_hash = Digest::SHA256.file(path).hexdigest
      new_hash = Digest::SHA256.hexdigest(content)
      existing_hash != new_hash
    end

    def ensure_import_exists(mode, path)
      return if mode == :local

      claude_md = ".claude/CLAUDE.md"
      import_line = case mode
      when :shared
        "@#{RULES_DIR}/#{GENERATED_FILE}"
      when :home
        "@~/#{path.sub(Dir.home + "/", "")}"
      else
        "@#{path}"
      end

      if File.exist?(claude_md)
        content = File.read(claude_md)
        return if content.include?(import_line)

        File.write(claude_md, content + "\n#{import_line}\n")
      else
        FileUtils.mkdir_p(".claude")
        File.write(claude_md, "# Project Memory\n\n#{import_line}\n")
      end
    end

    def humanize(predicate)
      predicate.tr("_", " ").capitalize
    end
  end
end
