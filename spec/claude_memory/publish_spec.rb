# frozen_string_literal: true

require "tmpdir"
require "fileutils"

RSpec.describe ClaudeMemory::Publish do
  let(:test_dir) { File.join(Dir.tmpdir, "publish_test_#{Process.pid}") }
  let(:db_path) { File.join(test_dir, "claude_memory.sqlite3") }
  let(:store) { ClaudeMemory::Store::SQLiteStore.new(db_path) }
  let(:publish) { described_class.new(store) }

  before do
    FileUtils.mkdir_p(test_dir)
    Dir.chdir(test_dir)
  end

  after do
    store.close
    Dir.chdir("/")
    FileUtils.rm_rf(test_dir)
  end

  def create_fact(predicate, object, status: "active")
    entity_id = store.find_or_create_entity(type: "repo", name: "test-repo")
    store.insert_fact(
      subject_entity_id: entity_id,
      predicate: predicate,
      object_literal: object,
      status: status
    )
  end

  describe "#generate_snapshot" do
    it "generates a markdown snapshot" do
      snapshot = publish.generate_snapshot
      expect(snapshot).to include("# Project Memory")
      expect(snapshot).to include("auto-generated by claude-memory")
    end

    context "with decisions" do
      it "includes decisions section" do
        create_fact("decision", "Use PostgreSQL for persistence")
        snapshot = publish.generate_snapshot
        expect(snapshot).to include("## Current Decisions")
        expect(snapshot).to include("Use PostgreSQL for persistence")
      end
    end

    context "with conventions" do
      it "includes conventions section" do
        create_fact("convention", "Use snake_case for variables")
        snapshot = publish.generate_snapshot
        expect(snapshot).to include("## Conventions")
        expect(snapshot).to include("Use snake_case for variables")
      end
    end

    context "with constraints" do
      it "includes constraints section" do
        create_fact("uses_database", "postgresql")
        create_fact("deployment_platform", "aws")
        snapshot = publish.generate_snapshot
        expect(snapshot).to include("## Technical Constraints")
        expect(snapshot).to include("postgresql")
        expect(snapshot).to include("aws")
      end
    end

    context "with conflicts" do
      it "includes conflicts section" do
        fact_a = create_fact("uses_database", "mysql")
        fact_b = create_fact("uses_database", "postgresql")
        store.insert_conflict(fact_a_id: fact_a, fact_b_id: fact_b)

        snapshot = publish.generate_snapshot
        expect(snapshot).to include("## Open Conflicts")
      end
    end
  end

  describe "#publish!" do
    context "shared mode" do
      it "writes to .claude/rules/" do
        create_fact("convention", "test rule")
        result = publish.publish!(mode: :shared)

        expect(result[:status]).to eq(:updated)
        expect(File.exist?(".claude/rules/claude_memory.generated.md")).to be true
      end

      it "creates CLAUDE.md with import if missing" do
        create_fact("convention", "test rule")
        publish.publish!(mode: :shared)

        expect(File.exist?(".claude/CLAUDE.md")).to be true
        expect(File.read(".claude/CLAUDE.md")).to include("@.claude/rules/claude_memory.generated.md")
      end

      it "adds import to existing CLAUDE.md" do
        FileUtils.mkdir_p(".claude")
        File.write(".claude/CLAUDE.md", "# Existing content\n")

        create_fact("convention", "test rule")
        publish.publish!(mode: :shared)

        content = File.read(".claude/CLAUDE.md")
        expect(content).to include("# Existing content")
        expect(content).to include("@.claude/rules/claude_memory.generated.md")
      end
    end

    context "local mode" do
      it "writes to local file" do
        create_fact("convention", "test rule")
        result = publish.publish!(mode: :local)

        expect(result[:status]).to eq(:updated)
        expect(File.exist?(".claude_memory.local.md")).to be true
      end
    end

    context "no-churn strategy" do
      it "does not rewrite if content unchanged" do
        create_fact("convention", "test rule")
        publish.publish!(mode: :shared)

        result = publish.publish!(mode: :shared)
        expect(result[:status]).to eq(:unchanged)
      end

      it "rewrites if content changed" do
        create_fact("convention", "first rule")
        publish.publish!(mode: :shared)

        create_fact("convention", "second rule")
        result = publish.publish!(mode: :shared)
        expect(result[:status]).to eq(:updated)
      end
    end
  end
end
